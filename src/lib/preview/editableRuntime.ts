/**
 * Editable Runtime Script
 *
 * This script is injected into the WebContainer preview to enable
 * visual editing capabilities. It handles:
 * - Element selection on click
 * - Hover highlighting
 * - Style updates from parent
 * - postMessage communication
 */

export const EDITABLE_RUNTIME_SCRIPT = `
(function() {
  'use strict';

  // ==========================================
  // STATE
  // ==========================================

  let editMode = false;
  let selectedElement = null;
  let hoveredElement = null;
  let highlightOverlay = null;
  let selectionOverlay = null;

  // ==========================================
  // HELPERS
  // ==========================================

  function getElementId(el) {
    // First check data-objects-id (generated by codeGenerator)
    if (el.dataset?.objectsId) return el.dataset.objectsId;
    // Then check data-id
    if (el.dataset?.id) return el.dataset.id;
    // Generate a unique ID based on path
    return getElementPath(el);
  }

  function getElementPath(el) {
    const path = [];
    let current = el;
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      if (current.id) {
        selector += '#' + current.id;
      } else if (current.className && typeof current.className === 'string') {
        const classes = current.className.split(' ').filter(c => c && !c.startsWith('objects-'));
        if (classes.length) {
          selector += '.' + classes.slice(0, 2).join('.');
        }
      }
      const siblings = current.parentElement ?
        Array.from(current.parentElement.children).filter(c => c.tagName === current.tagName) : [];
      if (siblings.length > 1) {
        const index = siblings.indexOf(current);
        selector += ':nth-of-type(' + (index + 1) + ')';
      }
      path.unshift(selector);
      current = current.parentElement;
    }
    return path.join(' > ');
  }

  function getElementRect(el) {
    const rect = el.getBoundingClientRect();
    return {
      top: rect.top,
      left: rect.left,
      width: rect.width,
      height: rect.height,
      right: rect.right,
      bottom: rect.bottom,
    };
  }

  function getElementStyles(el) {
    const computed = window.getComputedStyle(el);
    const inline = el.style;

    // Get relevant CSS properties
    const props = [
      'color', 'backgroundColor', 'fontSize', 'fontWeight', 'fontFamily',
      'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',
      'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft',
      'borderRadius', 'border', 'borderWidth', 'borderColor', 'borderStyle',
      'width', 'height', 'maxWidth', 'minWidth',
      'display', 'flexDirection', 'justifyContent', 'alignItems', 'gap',
      'textAlign', 'lineHeight', 'letterSpacing',
      'boxShadow', 'opacity', 'transform',
    ];

    const styles = {};
    const computedStyles = {};

    props.forEach(prop => {
      const camelProp = prop.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
      if (inline[camelProp]) {
        styles[camelProp] = inline[camelProp];
      }
      computedStyles[camelProp] = computed.getPropertyValue(prop) || computed[camelProp];
    });

    return { styles, computedStyles };
  }

  function getElementInfo(el) {
    const { styles, computedStyles } = getElementStyles(el);

    return {
      id: getElementId(el),
      tagName: el.tagName.toLowerCase(),
      className: el.className,
      textContent: el.childNodes.length === 1 && el.childNodes[0].nodeType === 3
        ? el.textContent?.trim().substring(0, 100)
        : null,
      componentName: el.dataset?.component || el.tagName.toLowerCase(),
      props: {
        className: el.className,
        ...(el.tagName === 'IMG' ? { src: el.src, alt: el.alt } : {}),
        ...(el.tagName === 'A' ? { href: el.href } : {}),
        ...(el.tagName === 'INPUT' ? { type: el.type, placeholder: el.placeholder, value: el.value } : {}),
      },
      styles,
      computedStyles,
      rect: getElementRect(el),
    };
  }

  // ==========================================
  // OVERLAYS
  // ==========================================

  function createOverlay(type) {
    const overlay = document.createElement('div');
    overlay.className = 'objects-overlay objects-' + type;
    overlay.style.cssText = \`
      position: fixed;
      pointer-events: none;
      z-index: 999999;
      transition: all 0.1s ease;
      box-sizing: border-box;
    \`;

    if (type === 'highlight') {
      overlay.style.border = '2px solid #60a5fa';
      overlay.style.backgroundColor = 'rgba(96, 165, 250, 0.1)';
    } else if (type === 'selection') {
      overlay.style.border = '2px solid #8b5cf6';
      overlay.style.backgroundColor = 'rgba(139, 92, 246, 0.1)';
    }

    document.body.appendChild(overlay);
    return overlay;
  }

  function updateOverlay(overlay, rect) {
    if (!overlay || !rect) return;
    overlay.style.display = 'block';
    overlay.style.top = rect.top + 'px';
    overlay.style.left = rect.left + 'px';
    overlay.style.width = rect.width + 'px';
    overlay.style.height = rect.height + 'px';
  }

  function hideOverlay(overlay) {
    if (overlay) overlay.style.display = 'none';
  }

  // ==========================================
  // ELEMENT SELECTION
  // ==========================================

  function selectElement(el) {
    if (selectedElement === el) return;

    selectedElement = el;

    if (el) {
      if (!selectionOverlay) {
        selectionOverlay = createOverlay('selection');
      }
      updateOverlay(selectionOverlay, getElementRect(el));

      const info = getElementInfo(el);
      sendMessage({
        type: 'objects:selected',
        ...info,
      });
    } else {
      hideOverlay(selectionOverlay);
      sendMessage({ type: 'objects:deselected' });
    }
  }

  function highlightElement(el) {
    if (hoveredElement === el) return;

    hoveredElement = el;

    if (el && el !== selectedElement) {
      if (!highlightOverlay) {
        highlightOverlay = createOverlay('highlight');
      }
      updateOverlay(highlightOverlay, getElementRect(el));

      sendMessage({
        type: 'objects:hover',
        id: getElementId(el),
        rect: getElementRect(el),
      });
    } else {
      hideOverlay(highlightOverlay);
      sendMessage({ type: 'objects:hover', id: null, rect: null });
    }
  }

  // ==========================================
  // EVENT HANDLERS
  // ==========================================

  function handleClick(e) {
    if (!editMode) return;

    // Don't select if clicking on our overlays
    if (e.target.classList?.contains('objects-overlay')) return;

    e.preventDefault();
    e.stopPropagation();

    // Find the best element to select (not body, html, or root)
    let target = e.target;
    while (target && (target === document.body || target === document.documentElement || target.id === 'root')) {
      target = null;
    }

    if (!target) {
      // Clicked on empty space - deselect
      selectElement(null);
      return;
    }

    selectElement(target);
  }

  function handleMouseMove(e) {
    if (!editMode) return;

    // Don't highlight our overlays
    if (e.target.classList?.contains('objects-overlay')) return;

    let target = e.target;
    while (target && (target === document.body || target === document.documentElement || target.id === 'root')) {
      target = null;
    }

    highlightElement(target);
  }

  function handleMouseLeave() {
    highlightElement(null);
  }

  function handleScroll() {
    // Update overlay positions on scroll
    if (selectedElement) {
      updateOverlay(selectionOverlay, getElementRect(selectedElement));
    }
    if (hoveredElement) {
      updateOverlay(highlightOverlay, getElementRect(hoveredElement));
    }
  }

  // ==========================================
  // POSTMESSAGE COMMUNICATION
  // ==========================================

  function sendMessage(data) {
    try {
      window.parent.postMessage(data, '*');
    } catch (e) {
      console.error('[EditableRuntime] Failed to send message:', e);
    }
  }

  function handleMessage(event) {
    const data = event.data;
    if (!data || typeof data !== 'object' || !data.type) return;
    if (!data.type.startsWith('objects:')) return;

    console.log('[EditableRuntime] Received:', data.type);

    switch (data.type) {
      case 'objects:ping':
        sendMessage({ type: 'objects:pong' });
        break;

      case 'objects:enable-edit-mode':
        editMode = true;
        document.body.style.cursor = 'crosshair';
        sendMessage({ type: 'objects:ready', version: '1.0.0' });
        break;

      case 'objects:disable-edit-mode':
        editMode = false;
        document.body.style.cursor = '';
        selectElement(null);
        highlightElement(null);
        break;

      case 'objects:select':
        if (data.id) {
          const el = document.querySelector('[data-objects-id="' + data.id + '"]') ||
                     document.querySelector('[data-id="' + data.id + '"]');
          selectElement(el);
        } else {
          selectElement(null);
        }
        break;

      case 'objects:highlight':
        if (data.id) {
          const el = document.querySelector('[data-objects-id="' + data.id + '"]') ||
                     document.querySelector('[data-id="' + data.id + '"]');
          highlightElement(el);
        } else {
          highlightElement(null);
        }
        break;

      case 'objects:update-style':
        if (data.id && data.style && selectedElement && getElementId(selectedElement) === data.id) {
          Object.assign(selectedElement.style, data.style);
          // Update selection overlay
          updateOverlay(selectionOverlay, getElementRect(selectedElement));
          // Notify parent of the change
          sendMessage({
            type: 'objects:style-updated',
            id: data.id,
            style: data.style,
          });
        }
        break;

      case 'objects:update-props':
        if (data.id && data.props && selectedElement && getElementId(selectedElement) === data.id) {
          // Update text content
          if (data.props.textContent !== undefined) {
            selectedElement.textContent = data.props.textContent;
          }
          // Update className
          if (data.props.className !== undefined) {
            selectedElement.className = data.props.className;
          }
          // Update src for images
          if (data.props.src !== undefined && selectedElement.tagName === 'IMG') {
            selectedElement.src = data.props.src;
          }
          // Update href for links
          if (data.props.href !== undefined && selectedElement.tagName === 'A') {
            selectedElement.href = data.props.href;
          }

          sendMessage({
            type: 'objects:props-changed',
            id: data.id,
            props: data.props,
          });
        }
        break;
    }
  }

  // ==========================================
  // INITIALIZATION
  // ==========================================

  function init() {
    // Add event listeners
    document.addEventListener('click', handleClick, true);
    document.addEventListener('mousemove', handleMouseMove, true);
    document.addEventListener('mouseleave', handleMouseLeave, true);
    document.addEventListener('scroll', handleScroll, true);
    window.addEventListener('message', handleMessage);

    // Notify parent that we're loaded
    sendMessage({ type: 'objects:loaded' });

    // Add styles for edit mode cursor
    const style = document.createElement('style');
    style.textContent = \`
      .objects-edit-mode * {
        cursor: crosshair !important;
      }
      .objects-overlay {
        pointer-events: none !important;
      }
    \`;
    document.head.appendChild(style);

    console.log('[EditableRuntime] Initialized');
  }

  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
`;

/**
 * Get the runtime script as an inline script tag
 */
export function getEditableRuntimeScriptTag(): string {
  return `<script>${EDITABLE_RUNTIME_SCRIPT}</script>`;
}

/**
 * Get the runtime as a separate JS file content
 */
export function getEditableRuntimeFileContent(): string {
  return EDITABLE_RUNTIME_SCRIPT;
}
